// Code generated by Boiler; DO NOT EDIT.
package kafkaoutbox

import (
  {{- range .OutboxPackages}}
  {{.ImportAlias}} "{{.ImportLine}}"
  {{- end}}
)

type Outbox struct {
  config   Config
  storage  Storage
  producer Producer
}

type Producer interface {
  SendMessage(msg *sarama.ProducerMessage) (partition int32, offset int64, err error)
}

type Storage interface {
  BatchRecords(ctx context.Context, tableName string) ([]*Record, error)
  DeleteRecord(ctx context.Context, tableName, recordID string) error
}

func New(config Config, storage Storage, producer Producer) *Outbox {
  return &Outbox{
    config:   config,
    storage:  storage,
    producer: producer,
  }
}

func (o *Outbox) Run(ctx context.Context) error {
  if err := o.Validate(); err != nil {
    return fmt.Errorf("outbox validation failed: %w", err)
  }
  for _, tableName := range tableNames {
    runJitter(o.config.JitterFactor)
    o.sendWithWorkers(ctx, tableName)

    log.Infof("kafka-outbox: sending started for: %s table", tableName)
  }
  log.Infof("kafka-outbox: sending in progress")

  return nil
}

func (o *Outbox) Validate() error {
  return validation.ValidateStruct(o,
    validation.Field(&o.config),
    validation.Field(&o.storage, validation.Required),
    validation.Field(&o.producer, validation.Required),
  )
}

func (o *Outbox) sendWithWorkers(ctx context.Context, tableName string) {
  for worker := 0; worker < int(o.config.WorkersCount); worker++ {
    runJitter(o.config.JitterFactor)
    go func() { o.send(ctx, tableName) }()
  }
}

func (o *Outbox) send(ctx context.Context, tableName string) {
  ticker := time.NewTicker(o.config.WorkerIdle)
  for {
    select {
    case <-ticker.C:
      if err := o.sendBatch(ctx, tableName); err != nil {
        log.Errorf("outbox.send: table: %s: error: %v", tableName, err)
      }
    case <-ctx.Done():
      log.Errorf("outbox.send: table: %s: context cancelled", tableName)
      return
    }
  }
}

func (o *Outbox) sendBatch(ctx context.Context, tableName string) error {
  records, err := o.storage.BatchRecords(ctx, tableName)
  if err != nil {
    return fmt.Errorf("storage.BatchRecords: %w", err)
  }
  var msgBuf []byte

  for _, record := range records {
    msgBuf, err = marshalRecord(tableName, record)
    if err != nil {
      return fmt.Errorf("marshalRecord: %w", err)
    }
    topicName, ok := tableTopics[tableName]
    if !ok {
      return fmt.Errorf("topic not found: %s table", tableName)
    }
    msgKey := record.ID

    msgHeaders := []sarama.RecordHeader{
      {
        Key:   []byte("action_typ"),
        Value: []byte(record.ActionTyp.String()),
      },
    }
    _, _, err = o.producer.SendMessage(&sarama.ProducerMessage{
      Topic:     topicName,
      Key:       sarama.StringEncoder(msgKey),
      Value:     sarama.StringEncoder(msgBuf),
      Headers:   msgHeaders,
      Timestamp: time.Now().UTC(),
    })
    if err != nil {
      return fmt.Errorf("producer.SendMessage: %w", err)
    }
    if err = o.storage.DeleteRecord(ctx, tableName, record.ID); err != nil {
      return fmt.Errorf("storage.DeleteRecord: %w", err)
    }
  }
  return nil
}

func marshalRecord(tableName string, record *Record) ([]byte, error) {
  typ, ok := tableTypes[tableName]
  if !ok {
    return nil, fmt.Errorf("type not found: %s table", tableName)
  }
  refTyp := reflect.TypeOf(typ)
  pb := reflect.New(refTyp).Interface().(protoreflect.ProtoMessage)

  pbOpts := protojson.UnmarshalOptions{
    AllowPartial:   true,
    DiscardUnknown: true,
  }
  if err := pbOpts.Unmarshal(record.JSONOut, pb); err != nil {
    return nil, fmt.Errorf("protojson.Unmarshal: %s table: %w", tableName, err)
  }
  buf, err := protojson.Marshal(pb)
  if err != nil {
    return nil, fmt.Errorf("protojson.Marshal: %s table: %w", tableName, err)
  }
  return buf, nil
}

func runJitter(factor time.Duration) error {
  randInt, err := rand.Int(rand.Reader, big.NewInt(factor.Milliseconds()))
  if err != nil {
    return fmt.Errorf("rand.Int: %w", err)
  }
  randJitter := time.Duration(randInt.Int64()) * time.Millisecond
  time.Sleep(randJitter)
  return nil
}

var tableTopics = map[string]string{
  {{- range .OutboxTables}}
  {{toLowerCamelCase .OutboxTableName}}TableName: "{{.OutboxTopicName}}",
  {{- end}}
}

var tableTypes = map[string]any{
  {{- range .OutboxTables}}
  {{toLowerCamelCase .OutboxTableName}}TableName: {{.OutboxProtoTyp}},
  {{- end}}
}

const (
  {{- range .OutboxTables}}
  {{toLowerCamelCase .OutboxTableName}}TableName = "{{.OutboxTableName}}"
  {{- end}}
)

var tableNames = []string{
  {{- range .OutboxTables}}
  {{toLowerCamelCase .OutboxTableName}}TableName,
  {{- end}}
}

