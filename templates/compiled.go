package templates

// RPC Generator
const (
  // Contracts const for compiled Boiler build with contracts template
  Contracts = "// Code generated by Boiler; DO NOT EDIT.\n\npackage handler\n\n{{range .Requests}}\n// {{.Name}}Request ...\ntype {{.Name}}Request struct {\n  {{range .Fields}}\n  {{.Name}} {{.Type}} `json:\"{{.Tag}}\"`\n  {{- end}}\n}\n{{- end}}\n\n{{range .Responses}}\n// {{.Name}}Response ...\ntype {{.Name}}Response struct {\n  {{range .Fields}}\n  {{.Name}} {{.Type}} `json:\"{{.Tag}}\"`\n  {{- end}}\n}\n{{- end}}\n\n{{range .TypeDefs}}\n// {{.Name}} ...\ntype {{.Name}} struct{\n  {{range .Fields}}\n  {{.Name}} {{.Type}} `json:\"{{.Tag}}\"`\n  {{- end}}\n}\n{{- end}}"
  // Handle const for compiled Boiler build with handle template
  Handle = "// Code generated by Boiler; YOU MAY CHANGE THIS.\n\npackage handler\n\nimport (\n\t\"net/http\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\n// Handle{{.Name}} stub ...\nfunc (h *Handler) Handle{{.Name}}(ctx *gin.Context) {\n  req := &{{.Name}}Request{}\n\n  if err := ctx.BindJSON(req); err != nil {\n    ctx.JSON(http.StatusBadRequest, err)\n    return\n  }\n\n  resp := &{{.Name}}Response{}\n  ctx.JSON(http.StatusOK, resp)\n}\n"
  // Handler const for compiled Boiler build with handler template
  Handler = "// Code generated by Boiler; DO NOT EDIT.\n\npackage handler\n\nimport (\n  \"github.com/gin-gonic/gin\"\n  log \"github.com/sirupsen/logrus\"\n)\n\n// Handler ...\ntype Handler struct {\n  addr string\n  g    *gin.Engine\n}\n\n// NewHandler ...\nfunc NewHandler() *Handler {\n  return &Handler{}\n}\n\ntype (\n  route  string\n  Routes map[route]gin.IRoutes\n)\n\nconst (\n    {{- range .Handles}}\n\t{{.Name}}Route route = \"{{.Route}}\"\n\t{{- end}}\n)\n\n// RegisterRoutes ...\nfunc (h *Handler) RegisterRoutes() Routes {\n  h.g = gin.New()\n  // Registered routes\n  return Routes{\n    {{- range .Handles}}\n    {{.Name}}Route: h.g.POST(string({{.Name}}Route), h.Handle{{.Name}}),\n    {{- end}}\n  }\n}\n\n// ServeHTTP ...\nfunc (h *Handler) ServeHTTP() {\n  go func() {\n    if err := h.g.Run(h.addr); err != nil {\n      log.Fatalf(\"ServeHTTP error: gin.Run: %v\", err)\n    }\n  }()\n}\n"
)

// Project Generator
const (
  // Main const for compiled Boiler build with main template
  Main = "// Code generated by Boiler. YOU MAY CHANGE THIS\npackage main\n\nfunc main() {\n    println(`\n        _           _ _\n       | |         (_) |\n       | |__   ___  _| | ___ _ __\n       | '_ \\ / _ \\| | |/ _ \\ '__|\n       | |_) | (_) | | |  __/ |\n       |_.__/ \\___/|_|_|\\___|_|\n    `)\n}"
  // Gomod const for compiled Boiler build with go mod template
  Gomod = "module main\n\ngo 1.19"
)

// Storage Generator
const (
  // FilterIfStmtWithPtr const for compiled Boiler build with filter if statement for zero typed filters
  FilterIfStmtWithPtr = "filters.%s.Ptr() != nil"
  // FilterIfStmtWithLen const for compiled Boiler build with filter if statement for slice typed filters
  FilterIfStmtWithLen = "len(filters.%s) > 0"

  Builders       = "// Code generated by Boiler; DO NOT EDIT.\n\npackage storage\n\nimport (\n  {{- range .BuildersPackages}}\n  {{.ImportAlias}} \"{{.ImportLine}}\"\n  {{- end}}\n)\n\nfunc newSelectBuilder() sq.SelectBuilder {\n  return sq.SelectBuilder{}.PlaceholderFormat(sq.Dollar)\n}\n\nfunc newInsertBuilder() sq.InsertBuilder {\n  return sq.InsertBuilder{}.PlaceholderFormat(sq.Dollar)\n}\n\nfunc newUpdateBuilder() sq.UpdateBuilder {\n  return sq.UpdateBuilder{}.PlaceholderFormat(sq.Dollar)\n}\n\nfunc newDeleteBuilder() sq.DeleteBuilder {\n  return sq.DeleteBuilder{}.PlaceholderFormat(sq.Dollar)\n}\n"
  Client         = "// Code generated by Boiler; DO NOT EDIT.\n\npackage storage\n\nimport (\n  {{- range .ClientPackages}}\n  {{.ImportAlias}} \"{{.ImportLine}}\"\n  {{- end}}\n)\n\nvar ErrZeroRowsRetrieved = errors.New(\"zero rows retrieved\")\n\ntype Client interface {\n  Pinger\n  Execer\n  Querier\n  Txer\n}\n\ntype Querier interface {\n  QueryContext(context.Context, string, ...any) (*sql.Rows, error)\n  QueryRowContext(context.Context, string, ...any) *sql.Row\n}\n\ntype Execer interface {\n  ExecContext(ctx context.Context, query string, args ...any) (sql.Result, error)\n}\n\ntype Txer interface {\n  Begin() (*sql.Tx, error)\n  BeginTx(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error)\n}\n\ntype Pinger interface {\n  PingContext(ctx context.Context) error\n}\n\ntype Builder interface {\n  ToSql() (statement string, args []any, err error)\n}\n\nfunc doQueryContext[Model any](ctx context.Context, querier Querier, builder Builder) ([]Model, error) {\n  statement, args, err := builder.ToSql()\n  if err != nil {\n    return nil, fmt.Errorf(\"builder.ToSql: %w\", err)\n  }\n  var models []Model\n  if err = sc.Select(ctx, querier, &models, statement, args); err != nil {\n    return nil, fmt.Errorf(\"sqlscan.Select: %w\", err)\n  }\n  if len(models) == 0 {\n    return nil, ErrZeroRowsRetrieved\n  }\n  return models, nil\n}\n\nfunc doExecContext(ctx context.Context, execer Execer, builder Builder) error  {\n  statement, args, err := builder.ToSql()\n  if err != nil {\n    return fmt.Errorf(\"builder.ToSql: %w\", err)\n  }\n  if _, err = execer.ExecContext(ctx, statement, args); err != nil {\n    return fmt.Errorf(\"execer.ExecContext: %w\", err)\n  }\n  return nil\n}\n\n\n\n\n"
  Consts         = "// Code generated by Boiler; DO NOT EDIT.\n\npackage storage\n\nimport (\n  {{- range .ConstsPackages}}\n  {{.ImportAlias}} \"{{.ImportLine}}\"\n  {{- end}}\n)\n\ntype tableName string\n\nconst (\n  {{- range .Models}}\n  {{.ModelName}}TableName = \"{{.SqlTableName}}\"\n  {{- end}}\n)\n\ntype (\n  {{- range .Models}}\n  {{toLowerCamelCase .ModelName}}Field string\n  {{- end}}\n)\n\n{{- range $m := .Models}}\nconst (\n  {{- range .ModelFields}}\n  {{.FieldName}}{{$m.ModelName}}Field {{toLowerCamelCase $m.ModelName}}Field = \"{{.SqlTableFieldName}}\"\n  {{- end}}\n)\n{{end}}"
  Implementation = "// Code generated by Boiler; DO NOT EDIT.\n\npackage {{toLowerCamelCase .ModelName}}_storage\n\nimport (\n  {{- range .ModelPackages}}\n  {{.ImportAlias}} \"{{.ImportLine}}\"\n  {{- end}}\n)\n\ntype {{.ModelName}}Storage struct {\n  client Client\n}\n\nfunc New{{.ModelName}}Storage(client Client) {{.ModelName}}Storage {\n  return &{{toLowerCamelCase .ModelName}}Storage{\n    client: client,\n  }\n}\n\nfunc (s *{{toLowerCamelCase .ModelName}}Storage) {{.ModelName}}s(ctx context.Context, input {{.ModelName}}Input) ([]*{{.ModelName}}, error) {\n  builder := newSelectBuilder().\n    Columns(\n      {{- range .ModelFields}}\n      string({{.FieldName}}{{.ModelName}}Field),\n      {{- end}}\n    ).\n    From(string({{.ModelName}}TableName))\n\n  if err := input.Pagination.validate(); err != nil {\n    return nil, fmt.Errorf(\"pagination.Validate: %w\", err)\n  }\n\n  offset, limit := input.Pagination.orDefault().toOffsetLimit()\n  builder = builder.Offset(offset).Limit(limit)\n\n  if input.Sort != nil {\n    builder = builder.OrderBy(input.Sort.{{toLowerCamelCase .ModelName}}Sort())\n  }\n\n  filters := input.Filters\n\n  {{- range .ModelFields}}\n  {{- range .ModelsFieldFilters}}\n  if {{.FilterIfStmt}} {\n    builder = builder.Where(sq.{{.FilterSqOperator}}{string({{.FieldName}}): filters.{{.FilterName}}{{withDot .FilterTypeSuffix}}})\n  }\n  {{- end}}\n  {{- end}}\n\n  return doQueryContext[*{{.ModelName}}](ctx, s.client, builder)\n}\n\nfunc (s *{{toLowerCamelCase .ModelName}}Storage) {{.ModelName}}(ctx context.Context, input {{.ModelName}}Input) (*{{.ModelName}}, error) {\n  builder := newSelectBuilder().\n    Columns(\n      {{- range .ModelFields}}\n      string({{.FieldName}}{{.ModelName}}Field),\n      {{- end}}\n    ).\n    From(string({{.ModelName}}TableName))\n\n  filters := input.Filters\n\n  {{- range .ModelFields}}\n  {{- range .ModelFieldFilters}}\n  if {{.FilterIfStmt}} {\n    builder = builder.Where(sq.Eq{string({{.FieldName}}): filters.{{.FilterName}}{{withDot .FilterTypeSuffix}}})\n  }\n  {{- end}}\n  {{- end}}\n\n  models, err := doQueryContext[*{{.ModelName}}](ctx, s.client, builder)\n  if err != nil {\n    return nil, err\n  }\n  return models[0], nil\n}\n\nfunc (s *{{toLowerCamelCase .ModelName}}Storage) Put{{.ModelName}}(ctx context.Context, input Put{{.ModelName}}Input) (*{{.ModelName}}, error) {\n  builder := newInsertBuilder().\n    Into(string({{.ModelName}}TableName))\n\n  fields := map[string]any{\n    {{- range .ModelFields}}\n    {{if eq .NotNullField true}}\n    string({{.FieldName}}{{.ModelName}}Field): input.{{.FieldName}},\n    {{end}}\n    {{- end}}\n  }\n\n  {{- range .ModelFields}}\n  {{if eq .NotNullField false}}\n  if input.{{.FieldName}}.Ptr() != nil {\n    fields[string({{.FieldName}}{{.ModelName}}Field)] = input.{{.FieldName}}{{withDot .FieldTypeSuffix}}\n  }\n  {{end}}\n  {{- end}}\n\n  builder = builder.SetMap(fields)\n\n  if err := doExecContext(ctx, s.client, builder); err != nil {\n    return nil, err\n  }\n\n  model := &{{.ModelName}}{\n    {{- range .ModelFields}}\n    {{.FieldName}}: input.{{.FieldName}},\n    {{- end}}\n  }\n\n  return model, nil\n}\n\nfunc (s *{{toLowerCamelCase .ModelName}}Storage) Update{{.ModelName}}(ctx context.Context, input Update{{.ModelName}}Input) (*{{.ModelName}}, error) {\n  builder := newUpdateBuilder().\n    Table(string({{.ModelName}}TableName))\n\n  fields := map[string]any{\n    {{- range .ModelFields}}\n    {{if eq .NotNullField true}}\n    {{if neq .FieldBadge \"pk\"}}\n    string({{.FieldName}}{{.ModelName}}Field): input.{{.FieldName}},\n    {{end}}\n    {{end}}\n    {{- end}}\n  }\n\n  {{- range .ModelFields}}\n  {{if eq .NotNullField false}}\n  {{if neq .FieldBadge \"pk\"}}\n  if input.{{.FieldName}}.Ptr() != nil {\n    fields[string({{.FieldName}}{{.ModelName}}Field)] = input.{{.FieldName}}{{withDot .FieldTypeSuffix}}\n  }\n  {{end}}\n  {{end}}\n  {{- end}}\n\n  builder = builder.SetMap(fields)\n\n  if err := doExecContext(ctx, s.client, builder); err != nil {\n    return nil, err\n  }\n\n  model := &{{.ModelName}}{\n    {{- range .ModelFields}}\n    {{.FieldName}}: input.{{.FieldName}},\n    {{- end}}\n  }\n\n  return model, nil\n}\n\nfunc (s *{{toLowerCamelCase .ModelName}}Storage) Delete{{.ModelName}}(ctx context.Context, input Delete{{.ModelName}}Input) error {\n  builder := newDeleteBuilder().\n    From(string({{.ModelName}}TableName)).\n    {{- range .ModelFields}}\n    {{if eq .FieldBadge \"pk\"}}\n    Where(sq.Eq{string({{.FieldName}}{{.ModelName}}Field): input.{{.FieldName}}})\n    {{end}}\n    {{- end}}\n\n  return doExecContext(ctx, s.client, builder)\n}\n"
  Interface      = "// Code generated by Boiler; DO NOT EDIT.\n\npackage storage\n\nimport (\n  {{- range .InterfacePackages}}\n  {{.ImportAlias}} \"{{.ImportLine}}\"\n  {{- end}}\n)\n\ntype {{.ModelName}}Storage interface {\n  {{.ModelName}}s(ctx context.Context, input {{.ModelName}}sInput) ([]*{{.ModelName}}, error)\n  {{.ModelName}}(ctx context.Context, input {{.ModelName}}Input) (*{{.ModelName}}, error)\n  Put{{.ModelName}}(ctx context.Context, input Put{{.ModelName}}Input) (*{{.ModelName}}, error)\n  Update{{.ModelName}}(ctx context.Context, input Update{{.ModelName}}Input) (*{{.ModelName}}, error)\n  Delete{{.ModelName}}(ctx context.Context, input Delete{{.ModelName}}Input) error\n}\n\ntype {{.ModelName}}Input struct {\n  Filters *{{.ModelName}}Filter\n}\n\ntype {{.ModelName}}Filter struct {\n  {{- range .ModelFields}}\n  {{- range .ModelFieldFilters}}\n  {{.FilterName}} {{.FilterType}}\n  {{- end}}\n  {{- end}}\n}\n\ntype Put{{.ModelName}}Input struct {\n  {{- range .ModelFields}}\n  {{.FieldName}} {{.FieldType}}\n  {{- end}}\n}\n\ntype Delete{{.ModelName}}Input struct {\n  {{- range .ModelFields}}\n  {{if eq .FieldBadge \"pk\"}}\n  {{.FieldName}} {{.FieldType}}\n  {{end}}\n  {{- end}}\n}\n\ntype Update{{.ModelName}}Input struct {\n  {{- range .ModelFields}}\n  {{if neq .FieldBadge \"pk\"}}\n  {{.FieldName}} {{.FieldType}}\n  {{end}}\n  {{- end}}\n}\n\ntype {{.ModelName}}sInput struct {\n  Filters    *{{.ModelName}}sFilters\n  Sort       *{{.ModelName}}sSort\n  Pagination *Pagination\n}\n\ntype {{.ModelName}}sSort struct {\n  Field {{toLowerCamelCase .ModelName}}Field\n  Order sortOrder\n}\n\nfunc (p *{{.ModelName}}sSort) {{toLowerCamelCase .ModelName}}Sort() string {\n  return fmt.Sprintf(\"%s %s\", p.Field, p.Order)\n}\n\ntype {{.ModelName}}sFilters struct {\n  {{- range .ModelFields}}\n  {{- range .ModelsFieldFilters}}\n  {{.FilterName}} {{.FilterType}}\n  {{- end}}\n  {{- end}}\n}\n"
  Models         = "// Code generated by Boiler; DO NOT EDIT.\n\npackage storage\n\nimport (\n  {{- range .Models}}\n  {{- range .ModelPackages}}\n  {{.ImportAlias}} \"{{.ImportLine}}\"\n  {{- end}}\n  {{- end}}\n)\n\n{{- range .Models}}\ntype {{.ModelName}} struct {\n  {{- range .ModelFields}}\n  {{.FieldName}} {{.FieldType}} {{.FieldDbTag}}\n  {{- end}}\n}\n{{end}}"
  Options        = "// Code generated by Boiler; DO NOT EDIT.\n\npackage storage\n\nimport (\n  \"fmt\"\n)\n\ntype sortOrder string\n\nconst (\n  SortOrderAsc  sortOrder = \"ASC\"\n  SortOrderDesc sortOrder = \"DESC\"\n  SortOrderRand sortOrder = \"RAND()\"\n)\n\ntype Pagination struct {\n  Page    uint64\n  PerPage uint64\n}\n\nfunc (p *Pagination) orDefault() *Pagination {\n  if p != nil {\n    return p\n  }\n  return &Pagination{\n    Page:    0,\n    PerPage: 100,\n  }\n}\n\nfunc (p *Pagination) validate() error {\n  if p == nil {\n    return nil\n  }\n  if p.Page < 0 {\n    return fmt.Errorf(\"pagination.Page=%d must be non-negative\", p.Page)\n  }\n  if p.PerPage < 0 {\n    return fmt.Errorf(\"pagination.PerPage=%d must be positive\", p.PerPage)\n  }\n  return nil\n}\n\nfunc (p *Pagination) toOffsetLimit() (offset uint64, limit uint64) {\n  offset = p.Page * p.PerPage\n  limit = p.PerPage\n  return\n}\n\n"
)

// Compiled Templates names
const (
  // NameMain name for compiled Main file template
  NameMain = "main"
  // NameGomod name for compiled Gomod file template
  NameGomod = "gomod"
)
