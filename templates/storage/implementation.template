// Code generated by Boiler; DO NOT EDIT. {{$modelName := .ModelName}}

package storage

import (
  {{- range .ImplementationPackages}}
  {{.ImportAlias}} "{{.ImportLine}}"
  {{- end}}
)

type {{toLowerCamelCase $modelName}}Storage struct {
  client client.Client
}

func New{{$modelName}}Storage(client client.Client) {{$modelName}}Storage {
  return &{{toLowerCamelCase $modelName}}Storage{
    client: client,
  }
}

func (s *{{toLowerCamelCase $modelName}}Storage) List{{$modelName}}(ctx context.Context, input List{{$modelName}}Input) ([]*models.{{$modelName}}, error) {
  builder := client.NewSelectBuilder().
    Columns(
      {{- range .ModelFields}}
      string({{.FieldName}}_{{$modelName}}_Field),
      {{- end}}
    ).
    From({{$modelName}}_TableName)

  if err := input.Pagination.validate(); err != nil {
    return nil, fmt.Errorf("pagination.Validate: %w", err)
  }

  offset, limit := input.Pagination.orDefault().toOffsetLimit()
  builder = builder.Offset(offset).Limit(limit)

  if input.Sort != nil {
    builder = builder.OrderBy(input.Sort.{{toLowerCamelCase $modelName}}Sort())
  }

  filters := input.Filters

  {{- range $modelField := .ModelFields}}
  {{- range .ModelsFieldFilters}}
  if {{.FilterIfStmt}} {
    builder = builder.Where(sq.{{.FilterSqOperator}}{string({{$modelField.FieldName}}_{{$modelName}}_Field): filters.{{.FilterName}}{{.FilterTypeSuffix}}})
  }
  {{- end}}
  {{- end}}

  return client.DoQueryContext[*models.{{$modelName}}](ctx, s.client, builder)
}

func (s *{{toLowerCamelCase $modelName}}Storage) {{$modelName}}(ctx context.Context, input {{$modelName}}Input) (*models.{{$modelName}}, error) {
  builder := client.NewSelectBuilder().
    Columns(
      {{- range .ModelFields}}
      string({{.FieldName}}_{{$modelName}}_Field),
      {{- end}}
    ).
    From({{$modelName}}_TableName)

  filters := input.Filters

  {{- range $modelField := .ModelFields}}
  {{- range .ModelFieldFilters}}
  if {{.FilterIfStmt}} {
    builder = builder.Where(sq.Eq{string({{$modelField.FieldName}}_{{$modelName}}_Field): filters.{{.FilterName}}{{.FilterTypeSuffix}}})
  }
  {{- end}}
  {{- end}}

  model, err := client.DoQueryContext[*models.{{$modelName}}](ctx, s.client, builder)
  if err != nil {
    return nil, err
  }

  return model[0], nil
}

func (s *{{toLowerCamelCase $modelName}}Storage) Put{{$modelName}}(ctx context.Context, input Put{{$modelName}}Input) (*models.{{$modelName}}, error) {
  builder := client.NewInsertBuilder().
    Into({{$modelName}}_TableName)

  fields := map[string]any{
    {{- range .ModelFields}}
    {{- if eq .NotNullField true}}
    string({{.FieldName}}_{{$modelName}}_Field): input.{{.FieldName}},
    {{- end}}
    {{- end}}
  }

  {{- range $modelField := .ModelFields}}
  {{- if eq .NotNullField false}}
  if input.{{.FieldName}}.Ptr() != nil {
    fields[string({{$modelField.FieldName}}_{{$modelName}}_Field)] = input.{{.FieldName}}{{.FieldTypeSuffix}}
  }
  {{- end}}
  {{- end}}

  builder = builder.SetMap(fields)

  if err := client.DoExecContext(ctx, s.client, builder); err != nil {
    return nil, err
  }

  model := &models.{{$modelName}}{
    {{- range .ModelFields}}
    {{.FieldName}}: input.{{.FieldName}},
    {{- end}}
  }

  return model, nil
}

func (s *{{toLowerCamelCase $modelName}}Storage) Update{{$modelName}}(ctx context.Context, input Update{{$modelName}}Input) (*models.{{$modelName}}, error) {
  builder := client.NewUpdateBuilder().
    Table({{$modelName}}_TableName)

  fields := map[string]any{
    {{- range .ModelFields}}
    {{- if eq .NotNullField true}}
    {{- if ne .FieldBadge "pk"}}
    string({{.FieldName}}_{{$modelName}}_Field): input.{{.FieldName}},
    {{- end}}
    {{- end}}
    {{- end}}
  }

  {{- range .ModelFields}}
  {{- if eq .NotNullField false}}
  {{- if ne .FieldBadge "pk"}}
  if input.{{.FieldName}}.Ptr() != nil {
    fields[string({{.FieldName}}_{{$modelName}}_Field)] = input.{{.FieldName}}{{.FieldTypeSuffix}}
  }
  {{- end}}
  {{- end}}
  {{- end}}

  builder = builder.
    SetMap(fields).
    {{- range .ModelFields}}
    {{- if eq .FieldBadge "pk"}}
    Where(sq.Eq{string({{.FieldName}}_{{$modelName}}_Field): input.{{.FieldName}}})
    {{- end}}
    {{- end}}

  if err := client.DoExecContext(ctx, s.client, builder); err != nil {
    return nil, err
  }

  model := &models.{{$modelName}}{
    {{- range .ModelFields}}
    {{.FieldName}}: input.{{.FieldName}},
    {{- end}}
  }

  return model, nil
}

func (s *{{toLowerCamelCase $modelName}}Storage) Delete{{$modelName}}(ctx context.Context, input Delete{{$modelName}}Input) error {
  builder := client.NewDeleteBuilder().
    From({{$modelName}}_TableName).
    {{- range .ModelFields}}
    {{- if eq .FieldBadge "pk"}}
    Where(sq.Eq{string({{.FieldName}}_{{$modelName}}_Field): input.{{.FieldName}}})
    {{- end}}
    {{- end}}

  return client.DoExecContext(ctx, s.client, builder)
}
