// Code generated by Boiler; DO NOT EDIT.

package storage

import (
  {{- range .ModelMethodsPackages}}
  {{.ImportAlias}} "{{.ImportLine}}"
  {{- end}}
)

func (s *Storage) CreateRocketLock(ctx context.Context, input CreateRocketLockInput) (*models.RocketLock, error) {
  query := `INSERT INTO rocket_locks(lock_id, locked_until)
            VALUES (%s, NOW() + INTERVAL %s)
            ON CONFLICT (lock_id)
            DO UPDATE SET locked_until = NOW() + INTERVAL %[2]s
            WHERE rocket_locks.locked_until < NOW()
            RETURNING lock_id, locked_until`

  builder := br.NewBuildedExpr(query, input.LockID, input.LockTTL)

  model, err := pg.GetCtx[*models.RocketLock](ctx, s.client.Executor(ctx), builder)
  if err != nil {
    if errors.Is(err, pe.ErrModelNotFound) {
      return nil, ErrRocketLockConflict
    }
    return nil, err
  }

  return model, nil
}

func (s *Storage) DeleteRocketLock(ctx context.Context, input DeleteRocketLockInput) (*models.RocketLock, error) {
  query := `DELETE FROM rocket_locks
            WHERE lock_id = %s
            RETURNING lock_id, locked_until`

  builder := br.NewBuildedExpr(query, input.LockID)

  model, err := pg.GetCtx[*models.RocketLock](ctx, s.client.Executor(ctx), builder)
  if err != nil {
    if errors.Is(err, pe.ErrModelNotFound) {
      return nil, ErrRocketLockNotFound
    }
    return nil, err
  }

  return model, nil
}

func (s *Storage) WithRocketLock(ctx context.Context, input WithRocketLockInput, fn func(ctx context.Context) error) error {
  if _, err := s.CreateRocketLock(ctx, CreateRocketLockInput{
    LockID:  input.LockID,
    LockTTL: input.LockTTL,
  }); err != nil {
    return fmt.Errorf("s.CreateLock: %w", err)
  }

  defer func() {
    if _, err := s.DeleteRocketLock(ctx, DeleteRocketLockInput{
      LockID: input.LockID,
    }); err != nil {
      log.Errorf("rocketLocksStorage: WithLock: s.DeleteLock: %v", err)
    }
  }()

  return fn(ctx)
}
