// Code generated by Boiler; DO NOT EDIT.

package storage

import (
  {{- range .ImplementationPackages}}
  {{.ImportAlias}} "{{.ImportLine}}"
  {{- end}}
)

type rocketLocksStorage struct {
  client client.Client
}

func (s *rocketLocksStorage) CreateLock(ctx context.Context, input CreateRocketLockInput) (*models.RocketLock, error) {
  query := `INSERT INTO __boiler_rocket_locks(lock_id, locked_until)
            VALUES ($1, NOW() + INTERVAL $2)
            ON CONFLICT DO UPDATE SET locked_until = NOW() + INTERVAL $2
            WHERE locked_until < NOW()
            RETURNING lock_id, locked_until`

  builder := client.NewBuildedExpr(query, input.LockID, input.LockTTL)

  model, err := client.DoQueryContext[*models.RocketLock](ctx, s.client, builder)
  if err != nil {
    if errors.Is(err, client.ErrModelNotFound) {
      return nil, ErrRocketLockConflict
    }
    return nil, err
  }

  return model[0], nil
}

func (s *rocketLocksStorage) DeleteLock(ctx context.Context, input DeleteRocketLockInput) (*models.RocketLock, error) {
  query := `DELETE FROM __boiler_rocket_locks
            WHERE lock_id = $1
            RETURNING lock_id, locked_until`

  builder := client.NewBuildedExpr(query, input.LockID)

  model, err := client.DoQueryContext[*models.RocketLock](ctx, s.client, builder)
  if err != nil {
    if errors.Is(err, client.ErrModelNotFound) {
      return nil, ErrRocketLockNotFound
    }
    return nil, err
  }

  return model[0], nil
}

func (s *rocketLocksStorage) WithLock(ctx context.Context, input WithRocketLockInput, fn func(ctx context.Context) error) error {
  if _, err := s.CreateLock(ctx, CreateRocketLockInput{
    LockID:  input.LockID,
    LockTTL: input.LockTTL,
  }); err != nil {
    return fmt.Errorf("s.CreateLock: %w", err)
  }

  defer func() {
    if _, err := s.DeleteLock(ctx, DeleteRocketLockInput{
      LockID: input.LockID,
    }); err != nil {
      log.Errorf("rocketLocksStorage: WithLock: s.DeleteLock: %v", err)
    }
  }()

  return fn(ctx)
}
