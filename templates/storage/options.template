// Code generated by Boiler; DO NOT EDIT.

package storage

import (
  {{- range .OptionsPackages}}
  {{.ImportAlias}} "{{.ImportLine}}"
  {{- end}}
)

const suffixReturning = "RETURNING *"

type sortOrder string

const (
  SortOrderAsc  sortOrder = "ASC"
  SortOrderDesc sortOrder = "DESC"
  SortOrderRand sortOrder = "RAND()"
)

type Pagination struct {
  Page    uint64
  PerPage uint64
}

func (p *Pagination) orDefault() *Pagination {
  if p != nil {
    return p
  }
  return &Pagination{
    Page:    0,
    PerPage: 100,
  }
}

func (p *Pagination) validate() error {
  if p == nil {
    return nil
  }
  if p.Page < 0 {
    return fmt.Errorf("pagination.Page=%d must be non-negative", p.Page)
  }
  if p.PerPage < 0 {
    return fmt.Errorf("pagination.PerPage=%d must be positive", p.PerPage)
  }
  return nil
}

func (p *Pagination) toOffsetLimit() (offset uint64, limit uint64) {
  offset = p.Page * p.PerPage
  limit = p.PerPage
  return
}

type Storage struct {
  executor pg.Executor
}

func NewStorage(executor pg.Executor) *Storage {
  return &Storage{
    executor: executor,
  }
}

func (s *Storage) WithTransaction(ctx context.Context, fTx func(*Storage) error) error {
  defer func() {
    if rec := recover(); rec != nil {
      log.Errorf("client.WithTransaction: panic recovered: %v", rec)
    }
  }()

  tx, err := s.executor.Begin(ctx)
  if err != nil {
    return fmt.Errorf("s.executor.BeginTx: %w", err)
  }
  txStorage := NewStorage(tx)

  if err = fTx(txStorage); err != nil {
    if errTx := tx.Rollback(ctx); errTx != nil {
      log.Errorf("Storage.WithTransaction: tx.Rollback: %v", errTx)
    }
    return err
  }

  if txErr := tx.Commit(ctx); txErr != nil {
    return fmt.Errorf("tx.Commit: %w", err)
  }
  return nil
}

